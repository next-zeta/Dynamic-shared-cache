// **1. 引言与目标** 本动态共享缓存管理器是一个关键组件，设计用于高速、多端口的网络交换或路由应用场景中，旨在高效且均衡地管理对大规模共享SRAM缓存资源的并发访问。其核心目标是在保证高吞吐量（支持 >250MHz 时钟频率）和端口公平性的前提下，动态地将来自16个独立端口的数据写入请求，智能地分配到32块独立的256Kbit **SRAM块**（总容量8Mbit）中，并最大化SRAM利用率。该模块采用了一种基于分布式**循环映射计数器阵列**、结合特定映射策略、周期性操作和异步更新的创新架构。

// **2. 核心架构与组件** 该管理器主要由以下部分构成：

// - **循环映射计数器阵列 (Cyclic Mapping Counter Array)**: 共32个**寄存器**，逻辑上标记为 R[i] (i=0…31)。每个寄存器内部包含一个11位的计数器 count[i]，用于存储其当前所映射SRAM的 **占用计数**。该计数值代表已被占用的**存储粒度**（例如16字节块）的数量。总共可管理 2^11 = 2048 个粒度，对应每块SRAM的256Kbit (32KB) 容量。

// - **SRAM映射函数 (SRAM Mapping Function)**: 寄存器与SRAM的映射关系并非顺序，而是采用 **步长为7的交错映射 (Stride-7 Interleaved Mapping)**，以促进负载均衡。初始状态下（或定义一个基准移位状态 offset=0），寄存器 i 映射到物理SRAM编号 s_idx = (i * 7) mod 32。此映射关系会随时间周期性移位。

// - **分配计数器 (Allocation Counters)**: 每个物理寄存器 R[i] 配备一个**分配计数器** Add[i]。当其映射的SRAM被分配用于存储时，该计数器负责增加 count[i] 的值。

// - **回收更新逻辑 (Reclamation Update Logic)**: 该模块采用分布式异步更新机制。共配置8个**回收更新逻辑** Sub[g] (g=0…7)，每个更新器固定关联到物理寄存器 R[4g]（即每4个寄存器构成一个逻辑单元，更新逻辑位于单元的起始位置）。Sub[g] 负责根据外部位图模块提供的已回收空间信息，周期性地减少 count[4g] 的值。

// - **分配逻辑单元 (Allocation Logic Units)**: 与**回收更新逻辑**的分布类似，32个寄存器被划分为8个4寄存器逻辑单元。每个单元（索引 g，包含寄存器 4g, 4g+1, 4g+2, 4g+3）内置不同的分配决策逻辑：

//   - **三输入比较器 Comp[g]**: 关联寄存器 4g+1, 4g+2, 4g+3。用于比较这三个寄存器映射的SRAM的剩余空间（通过比较 count 值），并选择最优者。

//   - **直接分配/握手机制 Alloc[g]**: 关联寄存器 4g。当有请求导向此单元的该部分时，直接分配其映射的SRAM，不进行空间比较。

// - **端口-单元固定映射 (Port-to-Unit Mapping)**: 16个输入端口 p (p=0…15) 与8个分配逻辑单元 g (g=0…7) 之间存在固定的映射关系：端口 p 的请求被路由到逻辑单元 g = floor(p / 2)。

//   - **偶数端口 (p = 0, 2, …, 14)**: 其请求由对应单元 g 的 直接分配/握手机制 Alloc[g] （关联寄存器 R[4g]）处理。

//   - **奇数端口 (p = 1, 3, …, 15)**: 其请求由对应单元 g 的 三输入比较器 Comp[g] （关联寄存器 R[4g+1] 到 R[4g+3]）处理。

// **3. 3周期工作循环** 管理器的核心逻辑运行在一个精确的3时钟周期循环中：

// - **周期 1: 比较选择与请求断言 (Compare/Select & Assert Add Request)**:

//   - 对于所有奇数端口 p 发出的有效分配请求：其对应的比较器 Comp[g] (g=floor(p/2)) 比较 count[4g+1], count[4g+2], count[4g+3] 的值，选择 count 最小（即剩余空间最大）的寄存器索引 i_start (i_start ∈ {4g+1, 4g+2, 4g+3})。

//   - 对于所有偶数端口 p 发出的有效分配请求：其对应的直接分配逻辑 Alloc[g] (g=floor(p/2)) 直接确定起始寄存器索引 i_start = 4g （前提是 count[4g] 未达到 almost_full 阈值）。

//   - 对于每个被选中的 i_start，计算出起始SRAM编号 s_start = map((i_start + offset) mod N) （offset 为当前**全局移位偏移量**）。将 s_start 作为分配结果输出给请求端口对应的地址生成器。

//   - 同时，为即将被分配的连续4个SRAM（s_start 到 (s_start + 3) % N）对应的物理寄存器发出内部的“加法计数请求”信号。

// - **周期 2: 执行计数更新 (Execute Add & Subtract)**:

//   - **加法更新**: 每个物理寄存器 i 的**分配计数器** Add[i] 统计在周期1中，有多少个分配决策的4地址批次包含了其当前映射的SRAM s_idx(i, offset)。设此数量为 num_reqs，则执行 count[i] = count[i] + num_reqs。

//   - **减法更新 (异步，仅 i mod 4 = 0)**: 对于每个 g=0..7，令 i=4g，**回收更新逻辑** Sub[g] 从位图模块获取在过去12个时钟周期内，其映射的SRAM s_idx(i, offset) 所**回收粒度数量** freed_amount (1到12之间的可变值)。执行 count[i] = count[i] - freed_amount。

// - **周期 3: 逻辑移位 (Logical Shift)**:

//   - 更新**全局移位偏移量**：offset = (offset - 3 + N) mod N。这使得在下一个周期1开始时，每个物理寄存器 i 开始处理逻辑上左移3位后的SRAM映射 s_idx(i, new_offset) 的计数。这确保了SRAM的负载信息在不同的比较器和更新器之间流动。

// **4. 分配策略与效率**

// - **批量分配 (Batch Allocation)**: 每个成功的分配决策（周期1）产生一个起始SRAM s_start，隐含地为数据包（拆分后）接下来的4个**存储粒度**预留了连续的SRAM块（s_start 到 s_start+3）。

// - **步调协调 (Pacing)**: 该3周期的分配决策速率与外部写入缓存模块处理速率（每3周期消耗1个**存储粒度**）相匹配。一次分配决策（提供4个地址基础）能够支持写入缓存模块连续12个时钟周期的数据填充需求 (4 granules * 3 cycles/granule = 12 cycles)。

// **5. 异步更新与负载均衡**

// - **异步性**: 空间回收的计数值更新是异步的，仅在寄存器逻辑上“旋转”到固定的**回收更新逻辑**位置时（每12周期一次）才发生，这意味着 count[i] 是对实际SRAM状态的一个略微延迟的估计。

// - **负载均衡机制**:

//   - **映射交错**: 步长7的SRAM映射将逻辑上相邻的寄存器分散到物理上不连续的SRAM，初步打散访问模式。

//   - **结构分布**: 将比较逻辑（较复杂）和直接分配逻辑（较简单）、以及**回收更新逻辑**（周期性负载）分布在4寄存器单元的不同位置，平衡了硬件资源和处理负载。

//   - **动态选择**: 通过比较剩余空间（对于奇数端口）来动态地将负载导向较空闲的SRAM组。

// **6. 工作边界与模式切换**

// - **Almost Full 阈值**: 系统为每个SRAM定义了一个固定的 almost_full 阈值。
[吐舌]
// - **模式切换**: 一旦任何一个SRAM的**占用计数** count[i] 达到或超过 threshold_almost_full，整个动态共享缓存管理器模块将停止其分配功能。此时，更高层级的系统控制器负责将缓存管理切换到静态分配模式（由另一个独立的硬件模块实现）。因此，本动态管理器设计不包含处理SRAM完全饱和或在almost_full状态下进行分配的逻辑。

// **7. 端口公平性** 该动态分配算法**提供端口级公平性 (Provides Port-Level Fairness)**，不考虑端口或数据包的优先级。所有端口根据其固定的单元映射和当前的SRAM空间状态参与分配过程。数据包级别的服务质量（QoS）由系统的其他部分（例如，读取调度器）来保证。

// **总结**: 该动态共享缓存管理器通过其独特的3周期运作、步长7交错映射、批量连续分配、分布式比较/分配逻辑以及异步更新机制，实现了一种高效、负载均衡且与外部模块步调协调的SRAM资源分配方案，特别适用于需要处理大量并发端口和高速数据流的场景，并在资源接近饱和时能平滑切换至备用管理模式。
//[计算almost_full阈值]
//[almost_full 判断模块]
module Manager (
    // 时钟与复位信号
    input logic clk,
    input logic rst_n,

    input logic port_req_valid_i[15:0],              //端口写入数据请求
    input logic [11:0] bitmap_space_refresh_i[7:0],  //异步更新位图空间

    output logic mode_change_o,                      //模式切换，当有一个及以上的寄存器达成almost_full后，切换动态共享缓存模式
    output logic [4:0] alloc_sram_number_o[15:0],    // 三时钟周期在“分配”循环的时钟周期中，输出分配了第几块SRAM
    output logic alloc_valid_o                       // 三时钟周期在“分配”循环的时钟周期中，拉高成功分配的信号
);
    //内部信号定义
    logic [2:0] cycle_cnt; //3时钟周期计数器
endmodule